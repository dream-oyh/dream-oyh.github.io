import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as l,c as p,d as e,b as n,a as s,e as a}from"./app-CQxE7HTL.js";const i={},r=e("h1",{id:"websocket",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#websocket"},[e("span",null,"Websocket")])],-1),d=e("p",null,[n("突然想学这个包是因为我院测试技术与信号处理课程作业，老师给出的题目是：“调用手机中的传感器，显示参数的动态变化”，经过一番搜索我发现了 python 中"),e("code",null,"websocket"),n("这个包，可以实现实时的手机传感器数据传输。")],-1),u=e("h2",{id:"sensor-server",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#sensor-server"},[e("span",null,"Sensor Server")])],-1),k={href:"https://github.com/umer0586/SensorServer",target:"_blank",rel:"noopener noreferrer"},h=a(`<p>Github 提供了一个开源的 Android apk，名为：“Sensor Server”，可以用来提供移动端传感器接口，利用<code>ws</code>互联网协议传输数据。移动端启动后，会提供一个 url，我们需要保证 PC 和移动端均连接到该 url 上。</p><p><code>websocket</code>和<code>HTTPS</code>提供了类似的套接字定义，以下服务器 url，即是<code>Sensor Server</code>提供的服务器地址。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>ws://&lt;ip&gt;:&lt;port&gt;/sensor/connect?type=&lt;type dir&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3),_=e("code",null,"type",-1),b=e("code",null,"Sensor Server",-1),m=e("code",null,"type",-1),g=e("code",null,"accelerometer-bma422",-1),v=e("code",null,"type",-1),y=e("code",null,"android.sensor.accelerometer",-1),f={href:"https://livepersoninc.github.io/ws-test-page/",target:"_blank",rel:"noopener noreferrer"},w=e("code",null,"url",-1),S=e("code",null,"ws",-1),x=e("code",null,"connect",-1),T=e("code",null,"json",-1),q=e("code",null,"values",-1),C=e("code",null,"values",-1),D={href:"https://developer.android.com/develop/sensors-and-location/sensors/sensors_motion?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},A={class:"hint-container details"},P=e("summary",null,"报错解决：an inscure WebSocket connection may not be initiated from a page loaded over HTTPS",-1),G=e("p",null,[n("我在 edge 浏览器打开测试网页后，输入正确的 "),e("code",null,"url"),n(" 后，连接不成功，但是我在移动端的火狐浏览器上是可以成功连接的，此时 PC 端报错为：")],-1),I=e("div",{class:"language-text line-numbers-mode","data-ext":"text","data-title":"text"},[e("pre",{class:"language-text"},[e("code",null,`Failed to construct 'WebSocket': An insecure WebSocket connection may not be initiated from a page loaded over HTTPS
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),N={href:"https://stackoverflow.com/questions/28625351/uncaught-securityerror-failed-to-construct-websocket-an-insecure-websocket-c",target:"_blank",rel:"noopener noreferrer"},W=e("code",null,"url",-1),E=e("code",null,"wss://",-1),Z=e("code",null,"connecting",-1),z=e("code",null,"url",-1),H=e("p",null,"后续：",-1),O=e("p",null,"第二天测试后，即使是在 Chrome 打开测试网站，依然无法 connect。",-1),R=e("p",null,[e("s",null,"省流：edge 不如 Chrome。")],-1),L=e("h2",{id:"websocket-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#websocket-1"},[e("span",null,"websocket")])],-1),V={href:"https://websocket-client.readthedocs.io/en/latest/",target:"_blank",rel:"noopener noreferrer"},B=e("h3",{id:"usage",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#usage"},[e("span",null,"Usage")])],-1),F={href:"https://github.com/websocket-client/websocket-client",target:"_blank",rel:"noopener noreferrer"},M=a(`<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>poetry <span class="token function">add</span> websocket-client
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,1),U=e("code",null,"import websocket",-1),j={href:"https://cloud.tencent.com/developer/article/1640430",target:"_blank",rel:"noopener noreferrer"},K=e("ul",null,[e("li",null,[n("长连接："),e("code",null,"websocket.WebSocketApp()"),n("对象")]),e("li",null,[n("短连接："),e("code",null,"websocket.WebSocket()"),n("对象")])],-1),Y=e("s",null,"（设成相同的使用方式不好吗！）",-1),J={href:"https://websocket-client.readthedocs.io/en/latest/examples.html",target:"_blank",rel:"noopener noreferrer"},Q=a(`<h2 id="socket" tabindex="-1"><a class="header-anchor" href="#socket"><span>Socket</span></a></h2><p>在本次机器人视觉比赛过程中，用到了 TCP 通信协议给另外一台位于相同网段下的电脑传输数据，并且有一定的要求，说明如下。</p><p>裁判盒软件接收参赛软件的数据格式</p><table><thead><tr><th style="text-align:center;">内容</th><th style="text-align:center;">字节数</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">DataType</td><td style="text-align:center;">4</td><td style="text-align:left;">数据类型，值为 0 表示发送队伍 ID，要求 ID 格式为字母和数字的组合，中间没有空格；值为 1 表示发送 3D 识别结果文件；</td></tr><tr><td style="text-align:center;">DataLength</td><td style="text-align:center;">4</td><td style="text-align:left;">其值为 N，即本次数据包 Data 的字节数</td></tr><tr><td style="text-align:center;">Data</td><td style="text-align:center;">4</td><td style="text-align:left;">实际接收数据内容，具体内容类型由 DataType 决定</td></tr></tbody></table><blockquote><p>采用大端的方式传输数据，例：直接将 int32 类型的 DataType、DataLength 复制到发送缓冲区的前 8 个字节，再将 Data 复制到发送缓冲区，最后发送数据。</p></blockquote><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> socket
<span class="token keyword">import</span> time
<span class="token keyword">def</span> <span class="token function">send_data</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    data_type_bytes <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">&quot;&gt;I&quot;</span><span class="token punctuation">,</span> data_type<span class="token punctuation">)</span>
    data_length_bytes <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">&quot;&gt;I&quot;</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 发送数据类型和数据长度</span>
    s<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>data_type_bytes <span class="token operator">+</span> data_length_bytes<span class="token punctuation">)</span>
    <span class="token comment"># 发送实际数据</span>
    s<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">&quot;utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 假设数据是字符串</span>

s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
s<span class="token punctuation">.</span>connet<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">&#39;ip-address&#39;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
send_data<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&#39;team-id&#39;</span><span class="token punctuation">)</span>
time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
send_data<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;START\\n&#39;</span><span class="token operator">+</span><span class="token string">&#39;Goal_ID=CA001;Num=1\\n&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>socket</code>是 python 自带的库，不需要安装环境，可以直接调用。</p><p>函数主体中，通过<code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code>创建通信协议的客户端，通过<code>connect()</code>函数连接服务端。</p><p>前面这些都没啥问题，把我们卡住的是发送数据，一开始我们完全没看懂裁判盒给出的缓冲区啥的都是啥意思 <s>（虽然现在也不懂）</s>，直到问了 GPT 才知道该怎么写。其中最核心的应该是<code>struct.pack</code>的打包机制。</p>`,9),X={href:"https://www.techtarget.com/searchnetworking/definition/big-endian-and-little-endian",target:"_blank",rel:"noopener noreferrer"},$={href:"https://docs.python.org/3/library/struct.html",target:"_blank",rel:"noopener noreferrer"},ee=e("code",null,">I",-1),ne=e("code",null,">",-1),te=e("code",null,"I",-1),se=e("code",null,"Undesigned int",-1),ae=e("code",null,".pack(format, v1, v2)",-1),oe=a(`<details class="hint-container details"><summary>粘包问题解决</summary><p>在实际应用的时候，我们需要先输送<code>0</code>，来告知队名，再输送<code>1</code>，来输送数据，但是如果把两行语句挨一块写，会导致缓冲区的数据量太大，从而导致粘包问题。</p><p>为此我们加入了<code>time.sleep(1)</code>来解决这个问题，先让前面一批数据传完，再传下一批数据。</p><p>这样确实能解决问题，在传完<code>0</code>之后，<code>1</code>也能够传成功了。但是问题又出现了，由于我们是一行一行传数据的，根据组委会要求，第一行是<code>START</code>，第二行数据是<code>Goal_ID=CA001;Num=0</code>，这样的话第二行数据传不过去，即使加入<code>time.sleep()</code>也只会传成功第一行数据。当时百思不得其解。</p><p>然后我同学提醒了我一句，粘包是针对多个包而言的，那你全打成一个包不就可以了，所以最后变成了：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&quot;data.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    data <span class="token operator">=</span> f<span class="token punctuation">.</span>readlins<span class="token punctuation">(</span><span class="token punctuation">)</span>
d <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  d <span class="token operator">+=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
send_data<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体原理是什么我现在也不清楚，但是加停止间隔、打包在一起发送，确实让数据传输变得非常稳定了。 <s>（没改之前也挺稳定的，稳定地每次都输不出去。。。）</s></p></details>`,1);function ce(le,pe){const t=c("ExternalLinkIcon");return l(),p("div",null,[r,d,u,e("p",null,[e("a",k,[n("Sensor Server 的 Github 仓库链接"),s(t)])]),h,e("p",null,[n("链接中的参数"),_,n("即表示传感器接口，"),b,n("中提供了一系列传感器接口的"),m,n("，如对于"),g,n("传感器，其"),v,n("为"),y,n("。"),e("a",f,[n("该网址"),s(t)]),n("提供了一个 web 端接口，用来测试传感器数据传输是否正常，打开网页后在"),w,n("栏中输入上述"),S,n("地址，点击"),x,n("后，即可连接至移动端，并且实时读取传感器数据。")]),e("p",null,[n("PC 端与服务器建立的链接为长链接，会不断从服务器读取传感器的参数值，并且返回一个"),T,n("文件，其中的"),q,n("便是传感器的测量值，各个传感器端口的"),C,n("含义，可以在"),e("a",D,[n("该链接"),s(t)]),n("中查找。")]),e("details",A,[P,G,I,e("p",null,[n("我去 Google 直接查了报错，查到了"),e("a",N,[n("这篇文章"),s(t)]),n("，然后我跟着这篇文章将"),W,n("地址改为"),E,n("后，edge 一直显示"),Z,n("，但是始终连接不上移动端，结合这篇文章的思路，我怀疑是浏览器拦截了传输，于是在 Chrome 中打开测试网站，将原来的"),z,n("填入，关闭网络代理后，PC 端与移动端连接成功。")]),H,O,R]),L,e("p",null,[e("a",V,[n("Documents"),s(t)])]),B,e("p",null,[e("a",F,[n("websocket-client"),s(t)]),n(" 为 python 的第三方库，需要安装，用 poetry 做包管理器：")]),M,e("p",null,[n("要使用 websocket-client，仅需要在 python 中"),U,n("即可。websocket 本质上是一个提供 PC 端与服务器连接的包，提供了两种连接方式，长连接和短连接，两种连接方式的差别可以见"),e("a",j,[n("这篇文档"),s(t)]),n("。")]),K,e("p",null,[n("两种对象的参数和使用方法不太相同 "),Y,n(" ，具体可见"),e("a",J,[n("文档"),s(t)]),n("（文档写的很详细啦！不想写教程啦！）")]),Q,e("blockquote",null,[e("p",null,[n("有关“大端”数据发送，可以见"),e("a",X,[n("这篇文档"),s(t)]),n("，区别于“小端”数据发送，“大端”数据时更符合我们读写数据的自然逻辑的。")])]),e("p",null,[e("a",$,[n("struct 官方文档"),s(t)]),n("——用来将字节打包成二进制数据。其中"),ee,n("是对字节的格式化设置，"),ne,n("表示数据以大端的对齐方式发送，"),te,n("表示数据以"),se,n("的格式发送。而"),ae,n("函数返回一个包含值 v1、v2、...根据格式字符串格式打包。参数必须与格式所需的值完全匹配。")]),oe])}const de=o(i,[["render",ce],["__file","websocket.html.vue"]]),ue=JSON.parse('{"path":"/code/python/websocket.html","title":"Websocket","lang":"zh-CN","frontmatter":{"date":"2024-02-27T00:00:00.000Z","icon":"bianzubeifen8","category":"Python 库","tag":"教程","description":"Websocket 突然想学这个包是因为我院测试技术与信号处理课程作业，老师给出的题目是：“调用手机中的传感器，显示参数的动态变化”，经过一番搜索我发现了 python 中websocket这个包，可以实现实时的手机传感器数据传输。 Sensor Server Sensor Server 的 Github 仓库链接 Github 提供了一个开源的 An...","head":[["meta",{"property":"og:url","content":"https://dream-oyh.github.io/code/python/websocket.html"}],["meta",{"property":"og:site_name","content":"Dream_oyh 的 blog"}],["meta",{"property":"og:title","content":"Websocket"}],["meta",{"property":"og:description","content":"Websocket 突然想学这个包是因为我院测试技术与信号处理课程作业，老师给出的题目是：“调用手机中的传感器，显示参数的动态变化”，经过一番搜索我发现了 python 中websocket这个包，可以实现实时的手机传感器数据传输。 Sensor Server Sensor Server 的 Github 仓库链接 Github 提供了一个开源的 An..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-18T12:21:30.000Z"}],["meta",{"property":"article:author","content":"OYH"}],["meta",{"property":"article:tag","content":"教程"}],["meta",{"property":"article:published_time","content":"2024-02-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-18T12:21:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Websocket\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-18T12:21:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"OYH\\",\\"email\\":\\"19859860010@163.com\\"}]}"]]},"headers":[{"level":2,"title":"Sensor Server","slug":"sensor-server","link":"#sensor-server","children":[]},{"level":2,"title":"websocket","slug":"websocket-1","link":"#websocket-1","children":[{"level":3,"title":"Usage","slug":"usage","link":"#usage","children":[]}]},{"level":2,"title":"Socket","slug":"socket","link":"#socket","children":[]}],"git":{"createdTime":1709049042000,"updatedTime":1710764490000,"contributors":[{"name":"dream同学0","email":"1399541701@qq.com","commits":3}]},"readingTime":{"minutes":5.75,"words":1725},"filePathRelative":"code/python/websocket.md","localizedDate":"2024年2月27日","excerpt":"\\n<p>突然想学这个包是因为我院测试技术与信号处理课程作业，老师给出的题目是：“调用手机中的传感器，显示参数的动态变化”，经过一番搜索我发现了 python 中<code>websocket</code>这个包，可以实现实时的手机传感器数据传输。</p>\\n<h2>Sensor Server</h2>\\n<p><a href=\\"https://github.com/umer0586/SensorServer\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Sensor Server 的 Github 仓库链接</a></p>\\n<p>Github 提供了一个开源的 Android apk，名为：“Sensor Server”，可以用来提供移动端传感器接口，利用<code>ws</code>互联网协议传输数据。移动端启动后，会提供一个 url，我们需要保证 PC 和移动端均连接到该 url 上。</p>","autoDesc":true}');export{de as comp,ue as data};
