import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as n,a as t,e,o as l}from"./app-Dt2nGrA-.js";const c="/images/llvm_structure.png",r="/images/msbuild.png",s="/images/make.png",p={},d=e('<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h1><h2 id="开发环境前置知识" tabindex="-1"><a class="header-anchor" href="#开发环境前置知识"><span>开发环境前置知识</span></a></h2><p>C++ 在 win 下的开发环境非常复杂，2024/06/24 我老老实实把<a href="https://www.cnblogs.com/w4ngzhen/p/17695080.html" target="_blank" rel="noopener noreferrer">这篇文章</a>看了，对编译、工具链等概念名词进行了区分，这在配置 C++ 开发环境之前是必要的。</p><p>首先，C++ 从<code>.cpp</code>文件到<code>.exe</code>文件需要很多步骤，具体如下图所示。主要分为四个部分，预处理器、编译器、汇编、链接。</p><figure><img src="https://raw.githubusercontent.com/dream-oyh/dream-oyh.github.io/images/C_compile_chain.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><em>Preprocessor</em> - 预处理器：通过头文件和宏定义，指示 C++ 编译器要处理哪些头文件和宏定义，在 C++ 中，预处理语句以<code>#</code>开头，由于其并不是 C++ 语句，所以不需要以分号结尾。预处理过程中，预处理器不需要理解 C++ 语法，只是一个文本处理工具，专注于代码结构的准备和预设条件的配置，进行文件包含替换、宏替换、条件编译等操作。有关预处理，可以详细看看<a href="https://juejin.cn/post/7322376878139195392" target="_blank" rel="noopener noreferrer">这篇文章</a></li><li><em>Compiler</em> - 编译器：编译器是将预处理后的 C++ 源代码转化为汇编代码，主要包括语法分析、语义分析、代码优化等，编译器需要理解具体的 C++ 语法，但是只要语法没有错误，编译器不论逻辑如何就都不会报错。</li><li><em>Assemble</em> - 汇编：将汇编代码转化为机器代码，由编译器完成，不需要我们太过担心，不过之前我们学单片机的时候有简单了解一下汇编语言，有机会也可以学学。</li><li><em>Linker</em> - 链接器：配置链接在生成可执行文件过程中，是非常重要的一项环节。配置的静态链接库或者动态链接库在这个环节下和可执行程序链接<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup> 在一起。简单来说，编译和汇编只能将<code>.cpp</code>文件转换为机器语言<code>.obj</code>文件，但是并不知道外部库、动态链接库或者其他文件里的函数与本代码的包含关系，这时候需要链接来将机器语言文件与外部库或其他编译好的文件&quot;链接&quot;起来，这才能让可执行程序执行。</li></ol><p>以上这一串下来，需要编译器和链接器互相协作，这整个流程所要用到的<code>.exe</code>合集就叫“工具链”。工具链是预处理器、编译器、汇编器、链接器，外加其他辅助调试工具的工具合集。</p><h2 id="工具链" tabindex="-1"><a class="header-anchor" href="#工具链"><span>工具链</span></a></h2><p>不同操作平台下，如 win, linux，对 C++ 的编译工具链是不一样的。</p><h3 id="windows-msvc" tabindex="-1"><a class="header-anchor" href="#windows-msvc"><span>windows - MSVC</span></a></h3><p>MSVC 是一套在 Windows 下处理 C++ 文件的一套工具链，而不是特指某个编译器或链接器，包含了<code>cl.exe</code>，<code>link.exe</code>和其他诸如 debugger 的调试工具等。</p><ul><li><code>cl.exe</code> 该程序起到了编译和链接的两个作用，但可以在命令行通过参数选择是否一起完成链接。若只需要<code>cl.exe</code>完成编译操作，则 MSVC 会让<code>link.exe</code>来继续完成链接。</li></ul><h4 id="windows-sdk" tabindex="-1"><a class="header-anchor" href="#windows-sdk"><span>Windows SDK</span></a></h4><p>何为 SDK？可以理解为系统已经写好的库组件，方便 C++ 程序的编写，类似 Python 中 pandas 库这种，为写代码提供的较为常用的库函数。</p><blockquote><p>适用于 Windows 11 版本 22H2 的 Windows SDK (10.0.22621) 提供用于生成 Windows 应用程序的最新标头、库、元数据和工具。</p></blockquote><p>所以需要在 Windows 上构建 C++ 应用，我们需要<strong>编译器工具链</strong>和<strong>标准 C、C++ 库文件以及 Windows 库文件</strong>。</p><p>而现在也有用户在使用 MinGW，其本质上是一套 GCC 工具链，但是 GCC 本来是用于 Linux 的，在 Windows 上并不适用，所以需要 MinGW 来使得 GCC 工具链也能在 Win 上运行，我在 Stack Overflow 上搜到了这样的一个简单解释：</p><blockquote><p>On a computer with Windows installed, the library that contains most ready-made executable code is not compatible with gcc compiler ... so to use this compiler in Windows you need a different library: that&#39;s where MinGW enters. MinGW provides, among other things, the library(ies) needed for making a C implementation together with gcc.</p></blockquote><h3 id="linux-gcc" tabindex="-1"><a class="header-anchor" href="#linux-gcc"><span>Linux GCC</span></a></h3><p>GCC 曾经是<code>GUN C Compiler</code>的缩写，也就是 GUN 的 C 语言编译器，然而随着不断的发展，GCC 已经能够处理 C++、Object-C、Go 语言等语言了，社区对它的定位也更上了一层，所以它现在的全称是<code>GNU Compiler Collection</code>，即 GNU 编译器集。</p><p>主要包含：</p><ul><li>gcc-core：即 GCC 编译器，用于完成预处理和编译过程，把 C 代码转换成汇编代码。</li><li>Binutils：除 GCC 编译器外的一系列小工具包括了链接器 ld，汇编器 as、目标文件格式查看器 readelf 等。</li><li>glibc：包含了主要的 C 语言标准函数库，C 语言中常常使用的打印函数 printf、malloc 函数就在 glibc 库中。</li></ul><h3 id="macos-clang-llvm" tabindex="-1"><a class="header-anchor" href="#macos-clang-llvm"><span>macOS Clang/LLVM</span></a></h3><p>它与 Linux 较为类似，通过内部的工具、命令行以及提供的标准库文件等完成构建应用的能力。二者关系为，Clang 在 LLVM 架构中是作为 C 家族语言（C、C++、Objective-C）的默认前端，可以无缝替换 GCC。</p><p>具体说一下什么是“前端”。首先要了解传统编译器的结构，如下图所示</p>',25),m=e('<ul><li>Frontend:前端--词法分析、语法分析、语义分析、生成中间代码</li><li>Optimizer:优化器--中间代码优化</li><li>Backend:后端--生成机器码</li></ul><p>而 llvm 的结构如下：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以 llvm 使得不同的前端后端使用统一的中间代码，如果需要新支持一种编程语言，只需要实现一个新的前端，而 C 语言的前端就是 Clang。这个前端其实就已经完成了编译器的工作，而 llvm 作为 Clang 的后端，会在 Clang 编译之后继续完成中间代码优化和可执行程序生成的操作。</p><h2 id="构建系统" tabindex="-1"><a class="header-anchor" href="#构建系统"><span>构建系统</span></a></h2><p>现在已经知道什么是工具链了，接下来说说什么是构建系统。从预处理、编译汇编到链接，这每一步都需要人为去配置，操纵编译器和链接器按流程运行，但是这样的配置非常麻烦，并且随着工程越来越复杂，编译配置项根据场景不同越来越复杂，直接调用命令容易出错，于是构建系统应运而生。构建系统在底层依然使用的是编译工具链，只是进行了一定的用户友好的抽象，并降低了项目编译的复杂度。</p><h3 id="windows-msbuild-与-sln、vcxproj" tabindex="-1"><a class="header-anchor" href="#windows-msbuild-与-sln、vcxproj"><span>Windows MSBuild 与 sln、vcxproj</span></a></h3><p>构建系统首先要有一定的规则才能构建出一套系统，在 Windows 上的构建系统主流是 MSBuild，它可以调用系统中安装的 MSVC。一般来说，MSBuild 的配置文件是<code>.sln</code>和<code>.vcxproj</code>文件。这些配置文件通常会指明一些关于编译构建的信息，例如项目工程所包含的源文件有哪些；相关库的头文件查找路径、二进制库文件查找路径；不同场景（Debug 或 Release）下的代码编译方式（是否代码优化，是否移除符号等）。</p><p>Visual Studio 在其中参与的作用是可视化和为了用户友好的抽象，当你在 IDE 中编写源码，配置编译选项，其实就在影响<code>.sln</code>和<code>.vsxproj</code>配置文件。另外，当你按下了 VS 上项目运行/构建的按钮的时候，底层就是在调用<code>msbuild.exe</code>。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="linux-的-make-与-makefile" tabindex="-1"><a class="header-anchor" href="#linux-的-make-与-makefile"><span>Linux 的 Make 与 Makefile</span></a></h3><p>（我看的别人的博客里已经写得很清楚了，就搬用过来啦）</p><p>与 Windows 上的 MSBuild 体系类似，make 这个命令行工具可以认为与 msbuild.exe 是同一层次，而 Makefiles 配置文件则是与.sln 和.vcxproj 文件是一个功能，指明了项目中具有哪些源代码、编译的规则逻辑等信息。当 make 执行的时候，读取 Makefile 配置文件，生成 GCC 相关的调用命令行，再调用 GCC 的相关命令行工具进行编译构建。于是，make、GCC 的关系和流程就可以如下描述了：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="生成构建系统的工具-cmake-元构建系统" tabindex="-1"><a class="header-anchor" href="#生成构建系统的工具-cmake-元构建系统"><span>生成构建系统的工具：CMake - 元构建系统</span></a></h3><p>如上所说，每个系统都有各自的构建系统，并不通用，因此想要实现跨平台的修改和运行就很困难。此时 CMake 提出，采用统一的构建系统生成工具，统一生成各个平台需要的配置文件，这样能有效解决跨平台问题。</p><ul><li>如果用户希望在 Windows 上构建应用的时候，那么这个工具就基于配置生成一套 msbuild 能够加载的<code>.sln</code>、<code>.vcxproj</code> 工程配置。于是，我们可以直接使用 <code>msbuild</code> 构建或是用 VS 打开工程开发构建；</li><li>如果用户希望在 Linux 上基于同样的代码构建 Linux 平台的应用，那么这个工具就利用同一份配置生成一套 <code>make</code> 能够加载的 <code>Makefile</code> 配置。于是，在 Linux，我们就可以使用 make 命令来构建这个应用了；</li></ul><h3 id="是构建系统又是元构建系统-xmake" tabindex="-1"><a class="header-anchor" href="#是构建系统又是元构建系统-xmake"><span>是构建系统又是元构建系统：XMake</span></a></h3><p>Xmake 是一个基于 Lua 的轻量级跨平台构建工具，<a href="https://xmake.io/#/zh-cn/" target="_blank" rel="noopener noreferrer">官方文档</a>很详细，可以直接阅读。</p><p>xmake 既可以作为构建系统来直接调用编译工具链进行项目编译（默认的），同时，还可以作为 CMake 的角色来生成特定的构建项目配置</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>链接的具体过程可以参考 <a href="https://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/" target="_blank" rel="noopener noreferrer">这篇博客</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li></ol></section>',22);function h(g,u){const o=a("FlowChart");return l(),n("div",null,[d,t(o,{id:"flowchart-116",code:"eJwrLrG1Ky5JLCqxUgjOLy1KTlVwzk9J5Uq1tUvNS7FS8E1MzsjMgwrmFxja2uUXpBYllmTm51kpuBXl55UAlQEljFAk/AtKMnMzq1KLgDLGKDJOicnZIB1cxSUaRZnpGSWaukBpQyS2ERLbGM5O5QIAf+o5tQ==",preset:"present"}),m])}const k=i(p,[["render",h],["__file","cpp.html.vue"]]),x=JSON.parse('{"path":"/code/cpp.html","title":"C++","lang":"zh-CN","frontmatter":{"date":"2024-03-18T00:00:00.000Z","icon":"code","description":"C++ 开发环境前置知识 C++ 在 win 下的开发环境非常复杂，2024/06/24 我老老实实把这篇文章看了，对编译、工具链等概念名词进行了区分，这在配置 C++ 开发环境之前是必要的。 首先，C++ 从.cpp文件到.exe文件需要很多步骤，具体如下图所示。主要分为四个部分，预处理器、编译器、汇编、链接。 Preprocessor - 预处理器...","head":[["meta",{"property":"og:url","content":"https://dream-oyh.github.io/code/cpp.html"}],["meta",{"property":"og:site_name","content":"Dream_oyh 的 blog"}],["meta",{"property":"og:title","content":"C++"}],["meta",{"property":"og:description","content":"C++ 开发环境前置知识 C++ 在 win 下的开发环境非常复杂，2024/06/24 我老老实实把这篇文章看了，对编译、工具链等概念名词进行了区分，这在配置 C++ 开发环境之前是必要的。 首先，C++ 从.cpp文件到.exe文件需要很多步骤，具体如下图所示。主要分为四个部分，预处理器、编译器、汇编、链接。 Preprocessor - 预处理器..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dream-oyh/dream-oyh.github.io/images/C_compile_chain.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-24T02:47:28.000Z"}],["meta",{"property":"article:author","content":"OYH"}],["meta",{"property":"article:published_time","content":"2024-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-24T02:47:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++\\",\\"image\\":[\\"https://raw.githubusercontent.com/dream-oyh/dream-oyh.github.io/images/C_compile_chain.png\\",\\"https://dream-oyh.github.io/images/llvm_structure.png\\",\\"https://dream-oyh.github.io/images/msbuild.png\\",\\"https://dream-oyh.github.io/images/make.png\\"],\\"datePublished\\":\\"2024-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-24T02:47:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"OYH\\",\\"email\\":\\"19859860010@163.com\\"}]}"]]},"headers":[{"level":2,"title":"开发环境前置知识","slug":"开发环境前置知识","link":"#开发环境前置知识","children":[]},{"level":2,"title":"工具链","slug":"工具链","link":"#工具链","children":[{"level":3,"title":"windows - MSVC","slug":"windows-msvc","link":"#windows-msvc","children":[]},{"level":3,"title":"Linux GCC","slug":"linux-gcc","link":"#linux-gcc","children":[]},{"level":3,"title":"macOS Clang/LLVM","slug":"macos-clang-llvm","link":"#macos-clang-llvm","children":[]}]},{"level":2,"title":"构建系统","slug":"构建系统","link":"#构建系统","children":[{"level":3,"title":"Windows MSBuild 与 sln、vcxproj","slug":"windows-msbuild-与-sln、vcxproj","link":"#windows-msbuild-与-sln、vcxproj","children":[]},{"level":3,"title":"Linux 的 Make 与 Makefile","slug":"linux-的-make-与-makefile","link":"#linux-的-make-与-makefile","children":[]},{"level":3,"title":"生成构建系统的工具：CMake - 元构建系统","slug":"生成构建系统的工具-cmake-元构建系统","link":"#生成构建系统的工具-cmake-元构建系统","children":[]},{"level":3,"title":"是构建系统又是元构建系统：XMake","slug":"是构建系统又是元构建系统-xmake","link":"#是构建系统又是元构建系统-xmake","children":[]}]}],"git":{"createdTime":1710779250000,"updatedTime":1719197248000,"contributors":[{"name":"dream-oyh","email":"1399541701@qq.com","commits":4},{"name":"dream同学0","email":"1399541701@qq.com","commits":3}]},"readingTime":{"minutes":8.11,"words":2434},"filePathRelative":"code/cpp.md","localizedDate":"2024年3月18日","excerpt":"\\n<h2>开发环境前置知识</h2>\\n<p>C++ 在 win 下的开发环境非常复杂，2024/06/24 我老老实实把<a href=\\"https://www.cnblogs.com/w4ngzhen/p/17695080.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">这篇文章</a>看了，对编译、工具链等概念名词进行了区分，这在配置 C++ 开发环境之前是必要的。</p>\\n<p>首先，C++ 从<code>.cpp</code>文件到<code>.exe</code>文件需要很多步骤，具体如下图所示。主要分为四个部分，预处理器、编译器、汇编、链接。</p>","autoDesc":true}');export{k as comp,x as data};
